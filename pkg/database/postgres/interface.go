// postgres/interface.go
package postgres

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

// DBTX is an interface that allows working with both pgx.Tx and pgxpool.Pool
// This interface matches what sqlc expects for query execution
type DBTX interface {
	Exec(context.Context, string, ...any) (pgconn.CommandTag, error)
	Query(context.Context, string, ...any) (pgx.Rows, error)
	QueryRow(context.Context, string, ...any) pgx.Row
}

// Querier is a generic interface for database queries
// This will be implemented by sqlc generated code
type Querier interface {
	// This interface is intentionally empty
	// It will be extended by the specific interfaces generated by sqlc
}

// TxKey is the context key for transactions
type txKeyType struct{}

var txKey = txKeyType{}

// GetDB returns the appropriate database interface for the context
// If there's a transaction in the context, it returns that
// Otherwise it returns the connection pool
func GetDB(ctx context.Context, pool *pgxpool.Pool) DBTX {
	tx := GetTx(ctx)
	if tx != nil {
		return tx
	}
	return pool
}

// GetTx extracts a transaction from the context if one exists
func GetTx(ctx context.Context) pgx.Tx {
	if tx, ok := ctx.Value(txKey).(pgx.Tx); ok {
		return tx
	}
	return nil
}

// WithTx adds a transaction to the context
func WithTx(ctx context.Context, tx pgx.Tx) context.Context {
	return context.WithValue(ctx, txKey, tx)
}

// Transaction represents a database transaction
// Used as a helper to work with sqlc generated code
type Transaction struct {
	tx pgx.Tx
}

// Exec executes a SQL query
func (t *Transaction) Exec(ctx context.Context, query string, args ...any) (pgconn.CommandTag, error) {
	return t.tx.Exec(ctx, query, args...)
}

// Query executes a query that returns rows
func (t *Transaction) Query(ctx context.Context, query string, args ...any) (pgx.Rows, error) {
	return t.tx.Query(ctx, query, args...)
}

// QueryRow executes a query that returns a single row
func (t *Transaction) QueryRow(ctx context.Context, query string, args ...any) pgx.Row {
	return t.tx.QueryRow(ctx, query, args...)
}

// ErrNoTx is returned when a transaction operation is attempted without an active transaction
var ErrNoTx = errors.New("no transaction in context")

// RunInTx runs a function within a transaction
// If the function returns an error, the transaction is rolled back
// Otherwise, the transaction is committed
func RunInTx(ctx context.Context, pool *pgxpool.Pool, txOptions pgx.TxOptions, fn func(context.Context) error) error {
	tx, err := pool.BeginTx(ctx, txOptions)
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}

	txCtx := WithTx(ctx, tx)

	defer func() {
		if p := recover(); p != nil {
			// Rollback on panic
			_ = tx.Rollback(context.Background())
			panic(p) // Re-throw panic after rollback
		}
	}()

	if err := fn(txCtx); err != nil {
		// Rollback on error
		if rbErr := tx.Rollback(ctx); rbErr != nil {
			return fmt.Errorf("error: %v, rollback error: %w", err, rbErr)
		}
		return err
	}

	// Commit transaction
	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("commit transaction: %w", err)
	}

	return nil
}

// SQLDBAdapter provides a sql.DB compatible interface for pgx
type SQLDBAdapter struct {
	pool *pgxpool.Pool
}

// DBFromPool creates a sql.DB instance from pgx for compatibility with libraries that require it
func DBFromPool(pool *pgxpool.Pool) *sql.DB {
	return sql.OpenDB(&SQLDBAdapter{pool: pool})
}

// Connect implements driver.Connector interface
func (a *SQLDBAdapter) Connect(ctx context.Context) (sql.Conn, error) {
	conn, err := a.pool.Acquire(ctx)
	if err != nil {
		return nil, fmt.Errorf("acquire connection from pool: %w", err)
	}

	return &sqlConn{conn: conn}, nil
}

// Driver implements driver.Connector interface
func (a *SQLDBAdapter) Driver() sql.Driver {
	return &sqlDriver{}
}

// sqlDriver and sqlConn implement the sql.Driver and sql.Conn interfaces
// These are simplified implementations - in production you'd need to
// implement all required methods properly
type sqlDriver struct{}

type sqlConn struct {
	conn *pgxpool.Conn
}

func (*sqlDriver) Open(string) (sql.Conn, error) {
	return nil, errors.New("open should not be called directly")
}

// Close implements sql.Conn.Close
func (c *sqlConn) Close() error {
	c.conn.Release()
	return nil
}

// Implementations of other sql.Conn methods would go here
// This is a simplified version for demonstration
func (c *sqlConn) PrepareContext(context.Context, string) (sql.Stmt, error) {
	return nil, errors.New("not implemented")
}

func (c *sqlConn) ExecContext(context.Context, string, ...any) (sql.Result, error) {
	return nil, errors.New("not implemented")
}

func (c *sqlConn) QueryContext(context.Context, string, ...any) (*sql.Rows, error) {
	return nil, errors.New("not implemented")
}

func (c *sqlConn) QueryRowContext(context.Context, string, ...any) *sql.Row {
	return nil
}

func (c *sqlConn) BeginTx(context.Context, sql.TxOptions) (sql.Tx, error) {
	return nil, errors.New("not implemented")
}

// Implement other required methods...
